<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>sqlite</title>
        </head><body>
        <h1>sqlite</h1>
        <!-- Generated by Ddoc from /Users/Nicolas/Documents/Develop/sqlite3/sqlite.d -->
Simple and easy SQLite interface.
<br><br>
This module provides a simple "object-oriented" interface to the SQLite database
engine. The complete C API is also available.
<br><br>

Objects in this interface (Database and Query) are reference-counted. When the
last reference goes out of scope, the objects are automatically closed and
finalized. The user does not have to explicitly open or close them.
<br><br>

Executable using this module must be linked to the SQLite library version 3.3.11
or later.

<br><br>
<b>Usage:</b><br>
<ol>   <li>Create a Database object, providing the path of the database file (or an
    empty path, or the reserved path ":memory:").</li>
    <li>Execute SQL code according to your need:
    <ul>       <li>If you don't need parameter binding, create a Query object with a
        single SQL statement and either use Query.execute() if you don't expect
        the query to return rows, or use Query.rows() directly in the other
        case.</li>
        <li>If you need parameter binding, create a Query object with a single
        SQL statement that includes binding names, and use Query.bind() as many
        times as necessary to bind all values. Then either use Query.execute()
        if you don't expect the query to return rows, or use Query.rows()
        directly in the other case.</li>
        <li>If you don't need parameter bindings and if you can ignore the rows
        that the query could return, you can use the facility function
        Database.executeSql(). In this case, more than one statements can be
        executed in one call, as long as they are separated by semi-colons.</li>
    </ul></li>
</ol>

<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=green>// Open a database in memory.
</font>Database db;
<font color=blue>try</font>
{
    db = Database(<font color=red>":memory:"</font>);
}
<font color=blue>catch</font> (SqliteException e)
{
    <font color=green>// Error opening the database.
</font>    <font color=blue>return</font>;
}

<font color=green>// Create a table.
</font><font color=blue>try</font>
{
    db.executeSql(
        <font color=red>"CREATE TABLE person (
            id INTEGER PRIMARY KEY,
            last_name TEXT NOT NULL,
            first_name TEXT,
            score REAL,
            photo BLOB)"</font>
    );
}
<font color=blue>catch</font> (SqliteException e)
{
    <font color=green>// Error creating the table.
</font>}

<font color=green>// Populate the table.
</font><font color=blue>try</font>
{
    <font color=blue>with</font> (Query(db, <font color=red>"INSERT INTO person
                    (last_name, first_name, score, photo)
                    VALUES (:last_name, :first_name, :score, :photo)"</font>))
    {
        <font color=green>// Explicit transaction so that either all insertions succeed or none.
</font>        db.transaction;
        <font color=blue>scope</font>(failure) db.rollback;
        <font color=blue>scope</font>(success) db.commit;

        bind(<font color=red>":last_name"</font>, <font color=red>"Smith"</font>);
        bind(<font color=red>":first_name"</font>, <font color=red>"Robert"</font>);
        bind(<font color=red>":score"</font>, 77.5);
        <font color=blue>ubyte</font>[] photo = ... <font color=green>// store the photo as raw array of data.
</font>        bind(<font color=red>":photo"</font>, photo);
        execute;

        reset; <font color=green>// need to reset the query after execution.
</font>        bind(<font color=red>":last_name"</font>, <font color=red>"Doe"</font>);
        bind(<font color=red>":first_name"</font>, <font color=red>"John"</font>);
        bind(<font color=red>":score"</font>, <font color=blue>null</font>);
        bind(<font color=red>":photo"</font>, <font color=blue>null</font>);
        execute;
    }
}
<font color=blue>catch</font> (SqliteException e)
{
    <font color=green>// Error executing the query.
</font>}
<font color=blue>assert</font>(db.totalChanges == 2); <font color=green>// Two 'persons' were inserted.
</font>
<font color=green>// Reading the table
</font><font color=blue>try</font>
{
    <font color=green>// Count the persons in the table (there should be two of them).
</font>    <font color=blue>auto</font> query = Query(db, <font color=red>"SELECT COUNT(*) FROM person"</font>);
    <font color=blue>assert</font>(query.rows.front[0].to!<font color=blue>int</font> == 2);

    <font color=green>// Fetch the data from the table.
</font>    query = Query(db, <font color=red>"SELECT * FROM person"</font>);
    <font color=blue>foreach</font> (row; query.rows)
    {
        <font color=blue>auto</font> id = row[<font color=red>"id"</font>].as!<font color=blue>int</font>;
        <font color=blue>auto</font> name = format(<font color=red>"%s, %s"</font>, row[<font color=red>"last_name"</font>].as!string, row[<font color=red>"first_name"</font>].as!string);
        <font color=blue>auto</font> score = row[<font color=red>"score"</font>].as!(<font color=blue>real</font>, 0.0); <font color=green>// score can be NULL, so provide 0.0 as a default value to replace NULLs.
</font>        <font color=blue>auto</font> photo = row[<font color=red>"photo"</font>].as!(<font color=blue>void</font>[]);
        ... <font color=green>// Use the data as you wish.
</font>    }
}
<font color=blue>catch</font> (SqliteException e)
{
    <font color=green>// Error reading the database.
</font>}
</pre>

<br><br>
<b>License:</b><br>
<a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.

<br><br>
<b>Author:</b><br>
Nicolas Sicard.<br><br>

<dl><dt><big>class <u>SqliteException</u>: object.Exception;
</big></dt>
<dd>Exception thrown then SQLite functions return error codes.<br><br>

</dd>
<dt><big>struct <u>Sqlite</u>;
</big></dt>
<dd>Metadata of the SQLite library.<br><br>

<dl><dt><big>static string <u>versionString</u>();
</big></dt>
<dd>Gets the library's version string (e.g. 3.6.12).<br><br>

</dd>
<dt><big>static int <u>versionNumber</u>();
</big></dt>
<dd>Gets the library's version number (e.g. 3006012).<br><br>

</dd>
</dl>
</dd>
<dt><big>struct <u>Database</u>;
</big></dt>
<dd>An interface to a SQLite database connection.
<br><br>
Once a <u>Database</u> object is created, the database is open and can be used
directly. The database is automatically closed when the last reference to the
object goes out of scope. If database error occur while the database is beeing
closed in the destructor, a SqliteException is thrown.
<br><br>

The <u>Database</u> object is not thread-safe, while the SQLite database engine
itself can be.<br><br>

<dl><dt><big>this(string <i>path</i>);
</big></dt>
<dd>Opens a database with the name passed in the parameter.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>path</i></td>
<td>the <i>path</i> of the database file. Can be empty or set to
        ":memory:" according to the SQLite specification.</td></tr>
</table><br>
<b>Throws:</b><br>
SqliteException when the database cannot be opened.<br><br>

</dd>
<dt><big>void <u>executeSql</u>(string <i>sql</i>);
</big></dt>
<dd>Execute one or many SQL statements. Rows returned by any of these statements
    are ignored.
<br><br>
<b>Throws:</b><br>
SqliteException in one of the SQL statements cannot be executed.<br><br>

</dd>
<dt><big>void <u>transaction</u>();
</big></dt>
<dd>Begins a <u>transaction</u>.
<br><br>
<b>Throws:</b><br>
SqliteException when a <u>transaction</u> has already been starter (simple
        transactions do not nest in SQLite).<br><br>

</dd>
<dt><big>void <u>commit</u>();
</big></dt>
<dd>Commits the current transaction.
<br><br>
<b>Throws:</b><br>
SqliteException when no transaction is started.<br><br>

</dd>
<dt><big>void <u>rollback</u>();
</big></dt>
<dd>Rolls back the current transaction.
<br><br>
<b>Throws:</b><br>
SqliteException when no transaction is started.<br><br>

</dd>
<dt><big>string <u>path</u>();
</big></dt>
<dd>Gets the database file path.<br><br>

</dd>
<dt><big>int <u>changes</u>();
</big></dt>
<dd>Gets the number of database rows that were changed, inserted or deleted by
    the most recently completed query.<br><br>

</dd>
<dt><big>int <u>totalChanges</u>();
</big></dt>
<dd>Gets the number of database rows that were changed, inserted or deleted
    since the database was opened.<br><br>

</dd>
<dt><big>int <u>errorCode</u>();
</big></dt>
<dd>Gets the SQLite error code of the last operation.<br><br>

</dd>
<dt><big>string <u>errorMsg</u>();
</big></dt>
<dd>Gets the SQLite error message of the last operation, including the error code.<br><br>

</dd>
<dt><big>sqlite3* <u>handle</u>();
</big></dt>
<dd>Gets the SQLite internal handle of the database connection.<br><br>

</dd>
</dl>
</dd>
<dt><big>struct <u>Query</u>;
</big></dt>
<dd>An interface to SQLite query execution.
<br><br>
Once a <u>Query</u> object is created, the query can be used directly. The object is
automatically disposed of when the last reference to the object goes out of
scope. If database error occur while the query is beeing closed in the
destructor, a SqliteException is thrown.
<br><br>

<u>Query</u> is not thread-safe.<br><br>

<dl><dt><big>this(ref Database <i>db</i>, string <i>sql</i>);
</big></dt>
<dd>Creates a new SQL query on an open database.
<br><br>
<b>Params:</b><br>
<table><tr><td>Database <i>db</i></td>
<td>the database on which the query will be run.</td></tr>
<tr><td>string <i>sql</i></td>
<td>the text of the query.</td></tr>
</table><br>
<b>Throws:</b><br>
SqliteException when the query cannot be prepared.<br><br>

</dd>
<dt><big>void <u>bind</u>(T)(string <i>parameter</i>, T <i>value</i>);
</big></dt>
<dd>Binds a value to a named parameter in the query.
<br><br>
<b>Params:</b><br>
<table><tr><td>parameter</td>
<td>the name of the parameter to <u>bind</u> to in the SQL prepared
        statement, including the symbol preceeding the actual name, e.g.
        ":id".</td></tr>
<tr><td>value</td>
<td>the bound value.</td></tr>
</table><br>
<b>Throws:</b><br>
SqliteException when parameter refers to an invalid binding or when
        the value cannot be bound.<br><br>

</dd>
<dt><big>void <u>bind</u>(T)(int <i>index</i>, T <i>value</i>);
</big></dt>
<dd>Binds a value to an indexed parameter in the query.
<br><br>
<b>Params:</b><br>
<table><tr><td>index</td>
<td>the index of the parameter to <u>bind</u> to in the SQL prepared
        statement.</td></tr>
<tr><td>value</td>
<td>the bound value.</td></tr>
</table><br>
<b>Throws:</b><br>
SqliteException when index is invalid or when the value cannot be
        bound.<br><br>

</dd>
<dt><big>RowSet <u>rows</u>();
</big></dt>
<dd>Gets the results of a query that returns rows.
<br><br>
There is no need to call execute() before a call to <u>rows</u>().<br><br>

</dd>
<dt><big>void <u>execute</u>();
</big></dt>
<dd>Executes the query.
<br><br>
Use rows() directly if the query is expected to return rows.<br><br>

</dd>
<dt><big>void <u>reset</u>(bool <i>clearBindings</i> = true);
</big></dt>
<dd>Resets a query, optionally clearing all bindings.
<br><br>
<b>Params:</b><br>
<table><tr><td>bool <i>clearBindings</i></td>
<td>sets whether the bindings should also be cleared.</td></tr>
</table><br>
<b>Throws:</b><br>
SqliteException when the query could not be <u>reset</u>.<br><br>

</dd>
</dl>
</dd>
<dt><big>struct <u>RowSet</u>;
</big></dt>
<dd>The results of a query that returns rows, with an InputRange interface.<br><br>

<dl><dt><big>bool <u>empty</u>();
</big></dt>
<dd>Tests whether no more rows are available.<br><br>

</dd>
<dt><big>Row <u>front</u>();
</big></dt>
<dd>Gets the current row.<br><br>

</dd>
<dt><big>void <u>popFront</u>();
</big></dt>
<dd>Jumps to the next row.<br><br>

</dd>
</dl>
</dd>
<dt><big>struct <u>Row</u>;
</big></dt>
<dd>A SQLite row.<br><br>

<dl><dt><big>int <u>columnCount</u>();
</big></dt>
<dd>Gets the number of columns in this row.<br><br>

</dd>
<dt><big>Column <u>opIndex</u>(int <i>index</i>);
</big></dt>
<dd>Gets the column at the given <i>index</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>int <i>index</i></td>
<td>the <i>index</i> of the column in the SELECT statement.</td></tr>
</table><br>
<b>Throws:</b><br>
SqliteException when the <i>index</i> is invalid.<br><br>

</dd>
<dt><big>Column <u>opIndex</u>(string <i>name</i>);
</big></dt>
<dd>Gets the column from its <i>name</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>name</i></td>
<td>the <i>name</i> of the column in the SELECT statement.</td></tr>
</table><br>
<b>Throws:</b><br>
SqliteException when the <i>name</i> is invalid.<br><br>

</dd>
</dl>
</dd>
<dt><big>struct <u>Column</u>;
</big></dt>
<dd>A SQLite column.<br><br>

<dl><dt><big>T <u>as</u>(T, T value = T.init)();
</big></dt>
<dd>Gets the value of the column converted to type T.
    If the value is NULL, it is replaced by value.<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>. Copyright Nicolas Sicard, 2011.

</small>
        </body></html>
