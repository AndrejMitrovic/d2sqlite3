<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>d2sqlite3</title>
        </head><body>
        <h1>d2sqlite3</h1>
        <!-- Generated by Ddoc from source/d2sqlite3.d -->
This module provides a simple "object-oriented" interface to the SQLite database engine.
See example in the documentation for the Database struct below. The (hopefully) complete C
API is available through the <tt>sqlite3</tt> module, which is publicly imported by this module.
<br><br>
<b>License:</b><br>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.

<br><br>
<b>Authors:</b><br>
Nicolas Sicard (dransic@gmail.com).

<br><br>

<dl><dt><big><a name="Sqlite3"></a>struct <u>Sqlite3</u>;
</big></dt>
<dd>Global SQLite utilities.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<u>Sqlite3</u>.config(SQLITE_CONFIG_MULTITHREAD);
<u>Sqlite3</u>.config(SQLITE_CONFIG_LOG,
    <font color=blue>function</font>(<font color=blue>void</font>* p, <font color=blue>int</font> code, <font color=blue>const</font>(<font color=blue>char</font>*) msg)
    {
        <font color=blue>import</font> std.stdio;
        writefln(<font color=red>"%05d | %s"</font>, code, msg.to!string);
    },
    <font color=blue>null</font>);
<u>Sqlite3</u>.initialize();
</pre>
<br><br>
<dl><dt><big><a name="Sqlite3.versionString"></a>static nothrow @property string <u>versionString</u>();
</big></dt>
<dd>Gets the library's version string (e.g. "3.8.7").<br><br>

</dd>
<dt><big><a name="Sqlite3.versionNumber"></a>static nothrow @property int <u>versionNumber</u>();
</big></dt>
<dd>Gets the library's version number (e.g. 3008007).<br><br>

</dd>
<dt><big><a name="Sqlite3.threadSafe"></a>static nothrow @property bool <u>threadSafe</u>();
</big></dt>
<dd>Tells whether SQLite was compiled with the thread-safe options.
<br><br>
<b>See Also:</b><br>
($LINK http://www.sqlite.org/c3ref/threadsafe.html).<br><br>

</dd>
<dt><big><a name="Sqlite3.initialize"></a>static void <u>initialize</u>();
<br><a name="Sqlite3.shutdown"></a>static void <u>shutdown</u>();
</big></dt>
<dd>Initializes or shuts down SQLite.<br><br>

</dd>
<dt><big><a name="Sqlite3.config"></a>void <u>config</u>(Args...)(int <i>code</i>, Args <i>args</i>);
</big></dt>
<dd>Sets a configuration option. Use before initialization and before execution of
    the first statement.
<br><br>
<b>See Also:</b><br>
<a href="http://www.sqlite.org/c3ref/config.html">http://www.sqlite.org/c3ref/config.html</a>.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Deterministic"></a>enum <u>Deterministic</u>: int;
</big></dt>
<dd>A caracteristic of user-defined functions or aggregates.<br><br>

<dl><dt><big><a name="Deterministic.yes"></a><u>yes</u></big></dt>
<dd>The returned value is the same if the function is called with the same parameters.<br><br>

</dd>
<dt><big><a name="Deterministic.no"></a><u>no</u></big></dt>
<dd>The returned value can vary even if the function is called with the same parameters.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Database"></a>struct <u>Database</u>;
</big></dt>
<dd>An SQLite database connection.
<br><br>
This struct is a reference-counted wrapper around a <tt>sqlite3*</tt> pointer.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=green>// Note: exception handling is left aside for clarity.
</font>
<font color=green>// Open a database in memory.
</font><font color=blue>auto</font> db = <u>Database</u>(<font color=red>":memory:"</font>);

<font color=green>// Create a table
</font>db.execute(
    <font color=red>"CREATE TABLE person (
        id INTEGER PRIMARY KEY,
        name TEXT NOT NULL,
        score FLOAT,
        photo BLOB
     )"</font>
);

<font color=green>// Populate the table
</font>
<font color=green>// Prepare an INSERT statement
</font><font color=blue>auto</font> statement = db.prepare(
    <font color=red>"INSERT INTO person (name, score, photo)
     VALUES (:name, :score, :photo)"</font>
);

<font color=green>// Bind values one by one (by parameter name or index)
</font>statement.bind(<font color=red>":name"</font>, <font color=red>"John"</font>);
statement.bind(<font color=red>":score"</font>, 77.5);
statement.bind(3, [0xDE, 0xEA, 0xBE, 0xEF]);
statement.execute();

statement.reset(); <font color=green>// Need to reset the statement after execution.
</font>
<font color=green>// Bind muliple values at once
</font>statement.bindAll(<font color=red>"John"</font>, 46.8, <font color=blue>null</font>);
statement.execute();

<font color=green>// Count the changes
</font><font color=blue>assert</font>(db.totalChanges == 2);

<font color=green>// Count the Johns in the table.
</font><font color=blue>auto</font> count = db.execute(<font color=red>"SELECT count(*) FROM person WHERE name == 'John'"</font>)
               .oneValue!<font color=blue>long</font>;
<font color=blue>assert</font>(count == 2);

<font color=green>// Read the data from the table lazily
</font><font color=blue>auto</font> results = db.execute(<font color=red>"SELECT * FROM person"</font>);
<font color=blue>foreach</font> (row; results)
{
    <font color=green>// Retrieve "id", which is the column at index 0, and contains an int,
</font>    <font color=green>// e.g. using the peek function (best performance).
</font>    <font color=blue>auto</font> id = row.peek!<font color=blue>long</font>(0);

    <font color=green>// Retrieve "name", e.g. using opIndex(string), which returns a ColumnData.
</font>    <font color=blue>auto</font> name = row[<font color=red>"name"</font>].as!string;

    <font color=green>// Retrieve "score", which is at index 3, e.g. using the peek function.
</font>    <font color=blue>auto</font> score = row.peek!<font color=blue>double</font>(<font color=red>"score"</font>);

    <font color=green>// Retrieve "photo", e.g. using opIndex(index),
</font>    <font color=green>// which returns a ColumnData.
</font>    <font color=blue>auto</font> photo = row[3].as!(<font color=blue>ubyte</font>[]);

    <font color=green>// ... and use all these data!
</font>}

<font color=green>// Read all the table in memory at once
</font><font color=blue>auto</font> data = RowCache(db.execute(<font color=red>"SELECT * FROM person"</font>));
<font color=blue>foreach</font> (row; data)
{
    <font color=blue>auto</font> id = row[0].as!<font color=blue>long</font>;
    <font color=blue>auto</font> last = row[<font color=red>"name"</font>];
    <font color=blue>auto</font> score = row[<font color=red>"score"</font>].as!<font color=blue>double</font>;
    <font color=blue>auto</font> photo = row[3].as!(<font color=blue>ubyte</font>[]);
    <font color=green>// etc.
</font>}
</pre>
<br><br>
<dl><dt><big><a name="Database.this"></a>this(string <i>path</i>, int <i>flags</i> = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE);
</big></dt>
<dd>Opens a database connection.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>path</i></td>
<td>The <i>path</i> to the database file. In recent versions of SQLite, the <i>path</i> can be
        an URI with options.</td></tr>
<tr><td>int <i>flags</i></td>
<td>Options <i>flags</i>.</td></tr>
</table><br>
<b>See Also:</b><br>
<a href="http://www.sqlite.org/c3ref/open.html">http://www.sqlite.org/c3ref/open.html</a> to know how to use the <i>flags</i>
    parameter or to use <i>path</i> as a file URI if the current configuration allows it.<br><br>

</dd>
<dt><big><a name="Database.handle"></a>pure nothrow @property @safe sqlite3* <u>handle</u>();
</big></dt>
<dd>Gets the SQLite internal handle of the database connection.<br><br>

</dd>
<dt><big><a name="Database.close"></a>void <u>close</u>();
</big></dt>
<dd>Explicitly closes the database.
<br><br>
After this function has been called successfully, using the database or one of its
    prepared statement is an error.<br><br>

</dd>
<dt><big><a name="Database.execute"></a>ResultRange <u>execute</u>(string <i>sql</i>);
</big></dt>
<dd>Executes a single SQL statement and returns the results directly. It's the equivalent
    of <tt>prepare(<i>sql</i>).<u>execute</u>()</tt>.
<br><br>
The results become undefined when the Database goes out of scope and is destroyed.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> db = Database(<font color=red>":memory:"</font>);
db.<u>execute</u>(<font color=red>"VACUUM"</font>);
</pre>
<br><br>
</dd>
<dt><big><a name="Database.run"></a>void <u>run</u>(string <i>sql</i>, scope bool delegate(ResultRange) <i>dg</i> = null);
</big></dt>
<dd>Runs an SQL script that can contain multiple statements.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>sql</i></td>
<td>The code of the script.</td></tr>
<tr><td>bool delegate(ResultRange) <i>dg</i></td>
<td>A delegate to call for each statement to handle the results. The passed
        ResultRange will be empty if a statement doesn't return rows. If the delegate
        return <b>false</b>, the execution is aborted.</td></tr>
</table><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> db = Database(<font color=red>":memory:"</font>);
db.<u>run</u>(<font color=red>`CREATE TABLE test1 (val INTEGER);
        CREATE TABLE test2 (val FLOAT);`</font>);
</pre>
<br><br>
</dd>
<dt><big><a name="Database.prepare"></a>Statement <u>prepare</u>(string <i>sql</i>);
</big></dt>
<dd>Prepares (compiles) a single SQL statement and returngs it, so that it can be bound to
    values before execution.
<br><br>
The statement becomes invalid if the Database goes out of scope and is destroyed.<br><br>

</dd>
<dt><big><a name="Database.begin"></a>void <u>begin</u>();
<br><a name="Database.commit"></a>void <u>commit</u>();
<br><a name="Database.rollback"></a>void <u>rollback</u>();
</big></dt>
<dd>Convenience functions equivalent to an SQL statement.<br><br>

</dd>
<dt><big><a name="Database.lastInsertRowid"></a>long <u>lastInsertRowid</u>();
</big></dt>
<dd>Returns the rowid of the last INSERT statement.<br><br>

</dd>
<dt><big><a name="Database.changes"></a>nothrow @property int <u>changes</u>();
</big></dt>
<dd>Gets the number of database rows that were changed, inserted or deleted by the most
    recently executed SQL statement.<br><br>

</dd>
<dt><big><a name="Database.totalChanges"></a>nothrow @property int <u>totalChanges</u>();
</big></dt>
<dd>Gets the number of database rows that were changed, inserted or deleted since the
    database was opened.<br><br>

</dd>
<dt><big><a name="Database.errorCode"></a>nothrow @property int <u>errorCode</u>();
</big></dt>
<dd>Gets the SQLite error code of the last operation.<br><br>

</dd>
<dt><big><a name="Database.createFunction"></a>void <u>createFunction</u>(alias fun, string name = __traits(identifier, fun), Deterministic det = Deterministic.yes)(void* <i>userData</i> = null);
</big></dt>
<dd>Creates and registers a simple function in the database.
<br><br>
<b>Params:</b><br>
<table><tr><td>fun</td>
<td>An alias to the D implementation of the function. The function <i>fun</i>
        must satisfy these criteria:
            <ul>                <li>It must not be a variadic.</li>
                <li>Its arguments must all have a type that is compatible with SQLite types:
                boolean, integral, floating point, string, or array of bytes (BLOB types).</li>
                <li>It can have only one parameter of type <tt>void*</tt> and it must be the
                last one.</li>
                <li>Its return value must also be of a compatible type.</li>
            </ul></td></tr>
<tr><td>name</td>
<td>The name that the function will have in the database; this name defaults to
        the identifier of <i>fun</i>.</td></tr>
<tr><td>det</td>
<td>Tells SQLite whether the result of the function is deterministic, i.e. if the
        result is the same when called with the same parameters. Recent versions of SQLite
        perform optimizations based on this. Set to <tt>Deterministic.no</tt> otherwise.</td></tr>
<tr><td>void* userData</td>
<td>A pointer to some user data, that will be passed to <i>fun</i> as
        its last argument if its type is <tt>void*</tt>.</td></tr>
</table><br>
<b>See Also:</b><br>
<a href="http://www.sqlite.org/c3ref/create_function.html">http://www.sqlite.org/c3ref/create_function.html</a>.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> string my_msg(string name)
{
    <font color=blue>return</font> <font color=red>"Hello, %s!"</font>.format(name);
}

<font color=blue>auto</font> db = Database(<font color=red>":memory:"</font>);
db.<u>createFunction</u>!my_msg();

<font color=blue>auto</font> msg = db.execute(<font color=red>"SELECT my_msg('John')"</font>)
             .oneValue!string;
<font color=blue>assert</font>(msg == <font color=red>"Hello, John!"</font>);
</pre>
<br><br><b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> string fun(string msg, <font color=blue>void</font>* data)
{
    <font color=blue>auto</font> ptr = <font color=blue>cast</font>(<font color=blue>int</font>*) data;
    <font color=blue>return</font> <font color=red>"%s %d"</font>.format(msg, *ptr);
}

<font color=blue>int</font> value = 42;
<font color=blue>auto</font> db = Database(<font color=red>":memory:"</font>);
db.<u>createFunction</u>!fun(&amp;value);
<font color=blue>auto</font> msg = db.execute(<font color=red>"SELECT fun('The number is')"</font>)
             .oneValue!string;
<font color=blue>assert</font>(msg == <font color=red>"The number is 42"</font>);
</pre>
<br><br>
</dd>
<dt><big><a name="Database.createAggregate"></a>void <u>createAggregate</u>(Aggregate, string name = __traits(identifier, Aggregate), Deterministic det = Deterministic.yes)();
</big></dt>
<dd>Creates and registers a new aggregate function in the database.
<br><br>
<b>Params:</b><br>
<table><tr><td>Aggregate</td>
<td>The <tt>struct</tt> implementing the aggregate. Aggregate must be a
        default-constructible <strong><tt>struct</tt></strong> that implements at least these two methods: <tt>        accumulate</tt> and <tt>result</tt>.</td></tr>
<tr><td>name</td>
<td>The name that the function will have in the database; this name defaults to
        the identifier of <i>Aggregate</i>.</td></tr>
<tr><td>det</td>
<td>Tells SQLite whether the result of the function is deterministic, i.e. if the
        result is the same when called with the same parameters. Recent versions of SQLite
        perform optimizations based on this. Set to <tt>Deterministic.no</tt> otherwise.</td></tr>
</table><br>
<b>See Also:</b><br>
<a href="http://www.sqlite.org/c3ref/create_function.html">http://www.sqlite.org/c3ref/create_function.html</a>.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>struct</font> weighted_average
{
    <font color=blue>double</font> total_value = 0.0;
    <font color=blue>double</font> total_weight = 0.0;

    <font color=blue>void</font> accumulate(<font color=blue>double</font> value, <font color=blue>double</font> weight)
    {
        total_value += value * weight;
        total_weight += weight;
    }

    <font color=blue>double</font> result()
    {
        <font color=blue>return</font> total_value / total_weight;
    }
}

<font color=blue>auto</font> db = Database(<font color=red>":memory:"</font>);
db.execute(<font color=red>"CREATE TABLE test (value FLOAT, weight FLOAT)"</font>);
db.<u>createAggregate</u>!(weighted_average, <font color=red>"w_avg"</font>)();

<font color=blue>auto</font> statement = db.prepare(<font color=red>"INSERT INTO test (value, weight) VALUES (?1, ?2)"</font>);
<font color=blue>double</font>[<font color=blue>double</font>] list = [11.5: 3, 14.8: 1.6, 19: 2.4];
<font color=blue>foreach</font> (value, weight; list)
{
    statement.bind(1, value);
    statement.bind(2, weight);
    statement.execute();
    statement.reset();
}

<font color=blue>auto</font> w_avg = db.execute(<font color=red>"SELECT w_avg(value, weight) FROM test"</font>)
               .oneValue!<font color=blue>double</font>;
<font color=blue>import</font> std.math: approxEqual;
<font color=blue>assert</font>(approxEqual(w_avg, (11.5*3 + 14.8*1.6 + 19*2.4)/(3 + 1.6 + 2.4)));
</pre>
<br><br>
</dd>
<dt><big><a name="Database.createCollation"></a>void <u>createCollation</u>(alias fun, string name = __traits(identifier, fun))();
</big></dt>
<dd>Creates and registers a collation function in the database.
<br><br>
<b>Params:</b><br>
<table><tr><td>fun</td>
<td>An alias to the D implementation of the function. The function <i>fun</i>
        must satisfy these criteria:
            <ul>                <li>If s1 is less than s2, <tt>ret &lt; 0</tt>.</li>
                <li>If s1 is equal to s2, <tt>ret == 0</tt>.</li>
                <li>If s1 is greater than s2, <tt>ret &gt; 0</tt>.</li>
                <li>If s1 is equal to s2, then s2 is equal to s1.</li>
                <li>If s1 is equal to s2 and s2 is equal to s3, then s1 is equal to s3.</li>
                <li>If s1 is less than s2, then s2 is greater than s1.</li>
                <li>If s1 is less than s2 and s2 is less than s3, then s1 is less than s3.</li>
            </ul></td></tr>
<tr><td>name</td>
<td>The name that the function will have in the database; this name defaults to
        the identifier of <i>fun</i>.</td></tr>
</table><br>
<b>See Also:</b><br>
<a href="http://www.sqlite.org/lang_aggfunc.html">http://www.sqlite.org/lang_aggfunc.html</a><br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> <font color=blue>int</font> my_collation(string s1, string s2)
{
    <font color=blue>import</font> std.uni;
    <font color=blue>return</font> icmp(s1, s2);
}

<font color=blue>auto</font> db = Database(<font color=red>":memory:"</font>);
db.<u>createCollation</u>!my_collation();
db.execute(<font color=red>"CREATE TABLE test (word TEXT)"</font>);

<font color=blue>auto</font> statement = db.prepare(<font color=red>"INSERT INTO test (word) VALUES (?)"</font>);
<font color=blue>foreach</font> (word; [<font color=red>"straße"</font>, <font color=red>"strasses"</font>])
{
    statement.bind(1, word);
    statement.execute();
    statement.reset();
}

<font color=blue>auto</font> word = db.execute(<font color=red>"SELECT word FROM test ORDER BY word COLLATE my_collation"</font>)
              .oneValue!string;
<font color=blue>assert</font>(word == <font color=red>"straße"</font>);
</pre>
<br><br>
</dd>
<dt><big><a name="Database.setUpdateHook"></a>void <u>setUpdateHook</u>(scope void delegate(int type, string dbName, string tableName, long rowid) <i>hook</i>);
</big></dt>
<dd>Registers an update hook.
<br><br>
<b>See Also:</b><br>
<a href="http://www.sqlite.org/c3ref/commit_hook.html">http://www.sqlite.org/c3ref/commit_hook.html</a>.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>int</font> i;
<font color=blue>auto</font> db = Database(<font color=red>":memory:"</font>);
db.<u>setUpdateHook</u>((<font color=blue>int</font> type, string dbName, string tableName, <font color=blue>long</font> rowid) {
    <font color=blue>assert</font>(type == SQLITE_INSERT);
    <font color=blue>assert</font>(dbName == <font color=red>"main"</font>);
    <font color=blue>assert</font>(tableName == <font color=red>"test"</font>);
    <font color=blue>assert</font>(rowid == 1);
    i = 42;
});
db.execute(<font color=red>"CREATE TABLE test (val INTEGER)"</font>);
db.execute(<font color=red>"INSERT INTO test VALUES (100)"</font>);
<font color=blue>assert</font>(i == 42);
</pre>
<br><br>
</dd>
<dt><big><a name="Database.setCommitHook"></a>void <u>setCommitHook</u>(int delegate() <i>hook</i>);
<br><a name="Database.setRollbackHook"></a>void <u>setRollbackHook</u>(void delegate() <i>hook</i>);
</big></dt>
<dd>Registers a commit hook or a rollback hook.
<br><br>
<b>Params:</b><br>
<table><tr><td>int delegate() <i>hook</i></td>
<td>For the commit <i>hook</i>, a delegate that should return 0 if the operation must be
        aborted or another value if it can continue.</td></tr>
</table><br>
<b>See Also:</b><br>
<a href="http://www.sqlite.org/c3ref/commit_hook.html">http://www.sqlite.org/c3ref/commit_hook.html</a>.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>int</font> i;
<font color=blue>auto</font> db = Database(<font color=red>":memory:"</font>);
db.setCommitHook({ i = 42; <font color=blue>return</font> SQLITE_OK; });
db.<u>setRollbackHook</u>({ i = 666; });
db.begin();
db.execute(<font color=red>"CREATE TABLE test (val INTEGER)"</font>);
db.rollback();
<font color=blue>assert</font>(i == 666);
db.begin();
db.execute(<font color=red>"CREATE TABLE test (val INTEGER)"</font>);
db.commit();
<font color=blue>assert</font>(i == 42);
</pre>
<br><br>
</dd>
<dt><big><a name="Database.setProgressHandler"></a>void <u>setProgressHandler</u>(int <i>pace</i>, int delegate() <i>hook</i>);
</big></dt>
<dd>Registers a progress handler hook.
<br><br>
<b>Params:</b><br>
<table><tr><td>int <i>pace</i></td>
<td>The approximate number of virtual machine instructions that are evaluated
        between successive invocations of the <i>hook</i>.</td></tr>
<tr><td>int delegate() <i>hook</i></td>
<td>A delegate that should return 0 if the operation must be aborted or another
        value if it can continue.</td></tr>
</table><br>
<b>See Also:</b><br>
<a href="http://www.sqlite.org/c3ref/progress_handler.html">http://www.sqlite.org/c3ref/progress_handler.html</a><br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Statement"></a>struct <u>Statement</u>;
</big></dt>
<dd>An SQLite statement execution.
<br><br>
This struct is a reference-counted wrapper around a <tt>sqlite3_stmt*</tt> pointer. Instances
of this struct are typically returned by <tt>Database.prepare()</tt>.<br><br>

<dl><dt><big><a name="Statement.handle"></a>@property sqlite3_stmt* <u>handle</u>();
</big></dt>
<dd>Gets the SQLite internal handle of the statement.<br><br>

</dd>
<dt><big><a name="Statement.bind"></a>void <u>bind</u>(T)(int <i>index</i>, T <i>value</i>);
</big></dt>
<dd>Binds values to parameters of this statement.
<br><br>
<b>Params:</b><br>
<table><tr><td>int index</td>
<td>The index of the parameter (starting from 1).</td></tr>
<tr><td>T value</td>
<td>The bound value. The type of value must be compatible with the SQLite</td></tr>
</table><br>
<b>types:</b><br>
it must be a boolean or numeric type, a string or an array.<br><br>

</dd>
<dt><big><a name="Statement.bind"></a>void <u>bind</u>(T)(string <i>name</i>, T <i>value</i>);
</big></dt>
<dd>Binds values to parameters of this statement.
<br><br>
<b>Params:</b><br>
<table><tr><td>string name</td>
<td>The name of the parameter, including the ':', '@' or '$' that introduced it.</td></tr>
<tr><td>T value</td>
<td>The bound value. The type of value must be compatible with the SQLite</td></tr>
</table><br>
<b>types:</b><br>
it must be a boolean or numeric type, a string or an array.

<br><br>
<b>Warning:</b><br>
While convenient, this overload of <tt><u>bind</u></tt> is less performant, because it has to
        retrieve the column index with a call to the SQLite function <tt>        sqlite3_bind_parameter_index</tt>.<br><br>

</dd>
<dt><big><a name="Statement.bindAll"></a>void <u>bindAll</u>(Args...)(Args <i>args</i>);
</big></dt>
<dd>Binds all the arguments at once in order.<br><br>

</dd>
<dt><big><a name="Statement.clearBindings"></a>void <u>clearBindings</u>();
</big></dt>
<dd>Clears the bindings.
<br><br>
This does not reset the statement. Use <tt>Statement.reset()</tt> for this.<br><br>

</dd>
<dt><big><a name="Statement.execute"></a>ResultRange <u>execute</u>();
</big></dt>
<dd>Executes the statement and return a (possibly empty) range of results.<br><br>

</dd>
<dt><big><a name="Statement.reset"></a>void <u>reset</u>();
</big></dt>
<dd>Resets a this statement before a new execution.
<br><br>
Calling this method invalidates any <tt>ResultRange</tt> struct returned by a previous call
    to <tt>Database.execute()</tt> or <tt>Statement.execute()</tt>.
<br><br>

    This does not clear the bindings. Use <tt>Statement.clear()</tt> for this.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="ResultRange"></a>struct <u>ResultRange</u>;
</big></dt>
<dd>An input range interface to access the results of the execution of a statement.
<br><br>
The elements of the range are <tt>Row</tt> structs. A <tt>Row</tt> is just a view of the current
row when iterating the results of a <tt><u>ResultRange</u></tt>. It becomes invalid as soon as <tt><u>ResultRange</u>.popFront()</tt> is called (it contains undefined data afterwards). Use <tt>RowCache</tt> to store the content of rows past the execution of the statement.
<br><br>

Instances of this struct are typically returned by <tt>Database.execute()</tt> or <tt>Statement.execute()</tt>.<br><br>

<dl><dt><big><a name="ResultRange.empty"></a>@property bool <u>empty</u>();
<br><a name="ResultRange.front"></a>@property Row <u>front</u>();
<br><a name="ResultRange.popFront"></a>void <u>popFront</u>();
</big></dt>
<dd>Range primitives.<br><br>

</dd>
<dt><big><a name="ResultRange.oneValue"></a>auto <u>oneValue</u>(T)();
</big></dt>
<dd>Gets only the first value of the first row returned by the execution of the statement.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> db = Database(<font color=red>":memory:"</font>);
db.execute(<font color=red>"CREATE TABLE test (val INTEGER)"</font>);
<font color=blue>auto</font> count = db.execute(<font color=red>"SELECT count(*) FROM test"</font>).<u>oneValue</u>!<font color=blue>long</font>;
<font color=blue>assert</font>(count == 0);
</pre>
<br><br>
</dd>
</dl>
</dd>
<dt><big><a name="Row"></a>struct <u>Row</u>;
</big></dt>
<dd>A SQLite row, implemented as a random-access range of ColumnData.<br><br>

<dl><dt><big><a name="Row.empty"></a>pure nothrow @property @safe bool <u>empty</u>();
<br><a name="Row.front"></a>nothrow @property ColumnData <u>front</u>();
<br><a name="Row.popFront"></a>pure nothrow @safe void <u>popFront</u>();
<br><a name="Row.save"></a>pure nothrow @property @safe Row <u>save</u>();
<br><a name="Row.back"></a>nothrow @property ColumnData <u>back</u>();
<br><a name="Row.popBack"></a>pure nothrow @safe void <u>popBack</u>();
<br><a name="Row.length"></a>pure nothrow @property @safe int <u>length</u>();
<br><a name="Row.opIndex"></a>ColumnData <u>opIndex</u>(int <i>index</i>);
</big></dt>
<dd>Range interface.<br><br>

</dd>
<dt><big><a name="Row.opIndex"></a>ColumnData <u>opIndex</u>(string <i>name</i>);
</big></dt>
<dd>Returns the data of a column as a <tt>ColumnData</tt>.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>name</i></td>
<td>The <i>name</i> of the column, as specified in the prepared statement with an AS
        clause.</td></tr>
</table><br>

</dd>
<dt><big><a name="Row.peek"></a>auto <u>peek</u>(T)(int <i>index</i>);
</big></dt>
<dd>Returns the data of a column.
<br><br>
Contraty to <tt>opIndex</tt>, the <tt><u>peek</u></tt> functions return the data directly,
    automatically cast to T, without the overhead of using a wrapped <tt>Variant</tt> (<tt>    ColumnData</tt>).

<br><br>
<b>Params:</b><br>
<table><tr><td>T</td>
<td>The type of the returned data. T must be a boolean, a built-in numeric type, a
        string, an array or a Variant.</td></tr>
<tr><td>int index</td>
<td>The index of the column in the prepared statement.</td></tr>
</table><br>
<b>Returns:</b><br>
A value of type T, or T.init if the data is NULL.

<br><br>
<b>Warning:</b><br>
The result is undefined if then index is out of range.<br><br>

</dd>
<dt><big><a name="Row.peek"></a>auto <u>peek</u>(T)(string <i>name</i>);
</big></dt>
<dd>Returns the data of a column.
<br><br>
Contraty to <tt>opIndex</tt>, the <tt><u>peek</u></tt> functions return the data directly,
    automatically cast to T, without the overhead of using a wrapped <tt>Variant</tt> (<tt>    ColumnData</tt>).

<br><br>
<b>Params:</b><br>
<table><tr><td>T</td>
<td>The type of the returned data. T must be a boolean, a built-in numeric type, a
        string, an array or a Variant.</td></tr>
<tr><td>string name</td>
<td>The name of the column, as specified in the prepared statement with an AS
        clause.</td></tr>
</table><br>
<b>Returns:</b><br>
A value of type T, or T.init if the data is NULL.

<br><br>
<b>Warning:</b><br>
The names of all the columns are tested each time this function is called: use
        numeric indexing for better performance.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="ColumnData"></a>struct <u>ColumnData</u>;
</big></dt>
<dd>The data retrived from a column, stored internally as a <tt>Variant</tt>, which is accessible
through "<tt>alias this</tt>".<br><br>

<dl><dt><big><a name="ColumnData.as"></a>auto <u>as</u>(T)(T <i>defaultValue</i> = T.init);
</big></dt>
<dd>Returns the data converted to T. If the data is NULL, defaultValue is
    returned.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="RowCache"></a>struct <u>RowCache</u>;
</big></dt>
<dd>Caches all the results of a <tt>Statement</tt> in memory as <tt>ColumnData</tt>.
<br><br>
Allows to iterate on the rows and their columns with an array-like interface. The rows can
be viewed as an array of <tt>ColumnData</tt> or as an associative array of <tt>ColumnData</tt>
indexed by the column names.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> db = Database(<font color=red>":memory:"</font>);
db.execute(<font color=red>"CREATE TABLE test (msg TEXT, num FLOAT)"</font>);

<font color=blue>auto</font> statement = db.prepare(<font color=red>"INSERT INTO test (msg, num) VALUES (?1, ?2)"</font>);
statement.bind(1, <font color=red>"ABC"</font>);
statement.bind(2, 123);
statement.execute();
statement.reset();
statement.bind(1, <font color=red>"DEF"</font>);
statement.bind(2, 456);
statement.execute();

<font color=blue>auto</font> results = db.execute(<font color=red>"SELECT * FROM test"</font>);
<font color=blue>auto</font> data = <u>RowCache</u>(results);
<font color=blue>assert</font>(data.length == 2);
<font color=blue>assert</font>(data[0].front.as!string == <font color=red>"ABC"</font>);
<font color=blue>assert</font>(data[0][1].as!<font color=blue>int</font> == 123);
<font color=blue>assert</font>(data[1][<font color=red>"msg"</font>].as!string == <font color=red>"DEF"</font>);
<font color=blue>assert</font>(data[1][<font color=red>"num"</font>].as!<font color=blue>int</font> == 456);
</pre>
<br><br>
<dl><dt><big><a name="RowCache.this"></a>this(ResultRange <i>results</i>);
</big></dt>
<dd>Creates and populates the cache from the <i>results</i> of the statement.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="literal"></a>string <u>literal</u>(T)(T <i>value</i>);
</big></dt>
<dd>Turns <i>value</i> into a literal that can be used in an SQLite expression.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>assert</font>(<font color=blue>null</font>.<u>literal</u> == <font color=red>"NULL"</font>);
<font color=blue>assert</font>(<font color=blue>false</font>.<u>literal</u> == <font color=red>"0"</font>);
<font color=blue>assert</font>(<font color=blue>true</font>.<u>literal</u> == <font color=red>"1"</font>);
<font color=blue>assert</font>(4.<u>literal</u> == <font color=red>"4"</font>);
<font color=blue>assert</font>(4.1.<u>literal</u> == <font color=red>"4.1"</font>);
<font color=blue>assert</font>(<font color=red>"foo"</font>.<u>literal</u> == <font color=red>"'foo'"</font>);
<font color=blue>assert</font>(<font color=red>"a'b'"</font>.<u>literal</u> == <font color=red>"'a''b'''"</font>);
<font color=blue>auto</font> a = <font color=blue>cast</font>(<font color=blue>ubyte</font>[]) x"DEADBEEF";
<font color=blue>assert</font>(a.<u>literal</u> == <font color=red>"'XDEADBEEF'"</font>);
</pre>
<br><br>
</dd>
<dt><big><a name="SqliteException"></a>class <u>SqliteException</u>: <u>object.Exception</u>;
</big></dt>
<dd>Exception thrown when SQLite functions return an error.<br><br>

<dl><dt><big><a name="SqliteException.code"></a>int <u>code</u>;
</big></dt>
<dd>The code of the error that raised the exception, or 0 if this code is not known.<br><br>

</dd>
<dt><big><a name="SqliteException.sql"></a>string <u>sql</u>;
</big></dt>
<dd>The SQL code that raised the exception, if applicable.<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. Copyright Nicolas Sicard, 2011-2014.

</small>
        </body></html>
