<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>d2sqlite3</title>
        </head><body>
        <h1>d2sqlite3</h1>
        <!-- Generated by Ddoc from source/d2sqlite3.d -->
Simple SQLite interface.
<br><br>
This module provides a simple "object-oriented" interface to the SQLite
database engine.
<br><br>

Objects in this interface (Database and Query) automatically create the SQLite
objects they need. They are reference-counted, so that when their last
reference goes out of scope, the underlying SQLite objects are automatically
closed and finalized. They are not thread-safe.
<br><br>

See example in the documentation for the Database struct below.
<br><br>

The C API is available through <tt>etc.c.sqlite3</tt>.

<br><br>
<b>License:</b><br>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.

<br><br>
<b>Authors:</b><br>
Nicolas Sicard (dransic@gmail.com).

<br><br>

<dl><dt><big><a name="Sqlite3"></a>struct <u>Sqlite3</u>;
</big></dt>
<dd>Metadata from the SQLite library.<br><br>

<dl><dt><big><a name="Sqlite3.versionString"></a>static @property string <u>versionString</u>();
</big></dt>
<dd>Gets the library's version string (e.g. 3.6.12).<br><br>

</dd>
<dt><big><a name="Sqlite3.versionNumber"></a>static @property int <u>versionNumber</u>();
</big></dt>
<dd>Gets the library's version number (e.g. 3006012).<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Database"></a>struct <u>Database</u>;
</big></dt>
<dd>An interface to a SQLite database connection.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=green>// Open a database in memory.
</font><u>Database</u> db;
<font color=blue>try</font>
{
    db = <u>Database</u>(<font color=red>":memory:"</font>);
}
<font color=blue>catch</font> (SqliteException e)
{
    <font color=green>// Error creating the database
</font>    <font color=blue>assert</font>(<font color=blue>false</font>, <font color=red>"Error: "</font> ~ e.msg);
}

<font color=green>// Create a table.
</font><font color=blue>try</font>
{
    db.execute(
        <font color=red>"CREATE TABLE person (
            id INTEGER PRIMARY KEY,
            last_name TEXT NOT NULL,
            first_name TEXT,
            score REAL,
            photo BLOB
         )"</font>
    );
}
<font color=blue>catch</font> (SqliteException e)
{
    <font color=green>// Error creating the table.
</font>    <font color=blue>assert</font>(<font color=blue>false</font>, <font color=red>"Error: "</font> ~ e.msg);
}

<font color=green>// Populate the table.
</font><font color=blue>try</font>
{
    <font color=blue>auto</font> query = db.query(
        <font color=red>"INSERT INTO person (last_name, first_name, score, photo)
         VALUES (:last_name, :first_name, :score, :photo)"</font>
    );
    
    <font color=green>// Bind everything with chained calls to params.bind().
</font>    query.bind(<font color=red>":last_name"</font>, <font color=red>"Smith"</font>);
    query.bind(<font color=red>":first_name"</font>, <font color=red>"John"</font>);
    query.bind(<font color=red>":score"</font>, 77.5);
    <font color=blue>ubyte</font>[] photo = <font color=blue>cast</font>(<font color=blue>ubyte</font>[]) <font color=red>"..."</font>; <font color=green>// Store the photo as raw array of data.
</font>    query.bind(<font color=red>":photo"</font>, photo);
    query.execute();
    
    query.reset(); <font color=green>// Need to reset the query after execution.
</font>    query.bind(<font color=red>":last_name"</font>, <font color=red>"Doe"</font>);
    query.bind(<font color=red>":first_name"</font>, <font color=red>"John"</font>);
    query.bind(3, 46.8); <font color=green>// Use of index instead of name.
</font>    query.bind(<font color=red>":photo"</font>, <font color=blue>cast</font>(<font color=blue>ubyte</font>[]) x"DEADBEEF");
    query.execute();
}
<font color=blue>catch</font> (SqliteException e)
{
    <font color=green>// Error executing the query.
</font>    <font color=blue>assert</font>(<font color=blue>false</font>, <font color=red>"Error: "</font> ~ e.msg);
}
<font color=blue>assert</font>(db.totalChanges == 2); <font color=green>// Two 'persons' were inserted.
</font>
<font color=green>// Reading the table
</font><font color=blue>try</font>
{
    <font color=green>// Count the Johns in the table.
</font>    <font color=blue>auto</font> query = db.query(<font color=red>"SELECT count(*) FROM person WHERE first_name == 'John'"</font>);
    <font color=blue>assert</font>(query.oneValue!<font color=blue>long</font> == 2);
    
    <font color=green>// Fetch the data from the table.
</font>    query = db.query(<font color=red>"SELECT * FROM person"</font>);
    <font color=blue>foreach</font> (row; query)
    {
        <font color=green>// Retrieve "id", which is the column at index 0, and contains an int,
</font>        <font color=green>// e.g. using the peek function.
</font>        <font color=blue>auto</font> id = row.peek!<font color=blue>long</font>(0);

        <font color=green>// Retrieve "score", which is at index 3, e.g. using the peek function.
</font>        <font color=blue>auto</font> score = row.peek!<font color=blue>double</font>(<font color=red>"score"</font>);

        <font color=green>// Retrieve "last_name" and "first_name", e.g. using opIndex(string),
</font>        <font color=green>// which returns a Variant.
</font>        <font color=blue>auto</font> name = format(<font color=red>"%s, %s"</font>, row[<font color=red>"last_name"</font>].get!string, row[<font color=red>"first_name"</font>].get!string);

        <font color=green>// Retrieve "photo", e.g. using opIndex(index),
</font>        <font color=green>// which returns a Variant.
</font>        <font color=blue>auto</font> photo = row[4].get!(<font color=blue>ubyte</font>[]);
        
        <font color=green>// ... and use all these data!
</font>    }
}
<font color=blue>catch</font> (SqliteException e)
{
    <font color=green>// Error reading the database.
</font>    <font color=blue>assert</font>(<font color=blue>false</font>, <font color=red>"Error: "</font> ~ e.msg);
}
</pre>
<br><br>
<dl><dt><big><a name="Database.this"></a>this(string <i>path</i>, int <i>flags</i> = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE);
</big></dt>
<dd>Opens a database connection.
<br><br>
The database is open using the sqlite3_open_v2 function.
    See <a href="http://www.sqlite.org/c3ref/open.html">http://www.sqlite.org/c3ref/open.html</a> to know how to use the <i>flags</i>
    parameter or to use <i>path</i> as a file URI if the current configuration allows it.<br><br>

</dd>
<dt><big><a name="Database.handle"></a>@property sqlite3* <u>handle</u>();
</big></dt>
<dd>Gets the SQLite internal handle of the database connection.<br><br>

</dd>
<dt><big><a name="Database.close"></a>void <u>close</u>();
</big></dt>
<dd>Explicitly closes the database.
<br><br>
Throws an SqliteException if the database cannot be closed.
<br><br>

    After this function has been called successfully, using this databse object
    or a query depending on it is a programming error.<br><br>

</dd>
<dt><big><a name="Database.execute"></a>void <u>execute</u>(string <i>sql</i>);
</big></dt>
<dd>Execute the given SQL code.
<br><br>
Rows returned by any statements are ignored.<br><br>

</dd>
<dt><big><a name="Database.query"></a>Query <u>query</u>(string <i>sql</i>);
</big></dt>
<dd>Creates a query on the database and returns it.<br><br>

</dd>
<dt><big><a name="Database.changes"></a>@property int <u>changes</u>();
</big></dt>
<dd>Gets the number of database rows that were changed, inserted or deleted by
    the most recently completed query.<br><br>

</dd>
<dt><big><a name="Database.totalChanges"></a>@property int <u>totalChanges</u>();
</big></dt>
<dd>Gets the number of database rows that were changed, inserted or deleted
    since the database was opened.<br><br>

</dd>
<dt><big><a name="Database.errorCode"></a>@property int <u>errorCode</u>();
</big></dt>
<dd>Gets the SQLite error code of the last operation.<br><br>

</dd>
<dt><big><a name="Database.errorMsg"></a>@property string <u>errorMsg</u>();
</big></dt>
<dd>Gets the SQLite error message of the last operation.<br><br>

</dd>
<dt><big><a name="Database.createAggregate"></a>void <u>createAggregate</u>(Aggregate, string name = Aggregate.stringof)();
</big></dt>
<dd>Creates and registers a new aggregate function in the database.
<br><br>
The type Aggregate must be a <strong><tt>struct</tt></strong> that implements at least these
    two methods: <tt>accumulate</tt> and <tt>result</tt>, and that must be default-constructible.
<br><br>

    See also: <a href="http://www.sqlite.org/lang_aggfunc.html">http://www.sqlite.org/lang_aggfunc.html</a><br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>struct</font> weighted_average
{
    <font color=blue>double</font> total_value = 0.0;
    <font color=blue>double</font> total_weight = 0.0;

    <font color=blue>void</font> accumulate(<font color=blue>double</font> value, <font color=blue>double</font> weight)
    {
        total_value += value * weight;
        total_weight += weight;
    }

    <font color=blue>double</font> result()
    {
        <font color=blue>return</font> total_value / total_weight;
    }
}

<font color=blue>auto</font> db = Database(<font color=red>":memory:"</font>);
db.execute(<font color=red>"CREATE TABLE test (value FLOAT, weight FLOAT)"</font>);
db.<u>createAggregate</u>!(weighted_average, <font color=red>"w_avg"</font>)();

<font color=blue>auto</font> query = db.query(<font color=red>"INSERT INTO test (value, weight) VALUES (:v, :w)"</font>);
<font color=blue>double</font>[<font color=blue>double</font>] list = [11.5: 3, 14.8: 1.6, 19: 2.4];
<font color=blue>foreach</font> (value, weight; list) {
    query.bind(<font color=red>":v"</font>, value);
    query.bind(<font color=red>":w"</font>, weight);
    query.execute();
    query.reset();
}

query = db.query(<font color=red>"SELECT w_avg(value, weight) FROM test"</font>);
<font color=blue>import</font> std.math: approxEqual;        
<font color=blue>assert</font>(approxEqual(query.oneValue!<font color=blue>double</font>, (11.5*3 + 14.8*1.6 + 19*2.4)/(3 + 1.6 + 2.4)));
</pre>
<br><br>
</dd>
<dt><big><a name="Database.createCollation"></a>void <u>createCollation</u>(alias fun, string name = __traits(identifier, fun))();
</big></dt>
<dd>Creates and registers a collation function in the database.
<br><br>
The function <i>fun</i> must satisfy these criteria:
    <ul>        <li>It must take two string arguments, e.g. s1 and s2.</li>
        <li>Its return value <tt>ret</tt> must satisfy these criteria (when s3 is any other string):
            <ul>                <li>If s1 is less than s2, <tt>ret &lt; 0</tt>.</li>
                <li>If s1 is equal to s2, <tt>ret == 0</tt>.</li>
                <li>If s1 is greater than s2, <tt>ret &gt; 0</tt>.</li>
                <li>If s1 is equal to s2, then s2 is equal to s1.</li>
                <li>If s1 is equal to s2 and s2 is equal to s3, then s1 is equal to s3.</li>
                <li>If s1 is less than s2, then s2 is greater than s1.</li>
                <li>If s1 is less than s2 and s2 is less than s3, then s1 is less than s3.</li>
            </ul>
        </li>
    </ul>
    The function will have the name <i>name</i> in the database; this name defaults to
    the identifier of the function fun.
<br><br>

    See also: <a href="http://www.sqlite.org/lang_aggfunc.html">http://www.sqlite.org/lang_aggfunc.html</a><br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> <font color=blue>int</font> my_collation(string s1, string s2)
{
    <font color=blue>import</font> std.uni;
    <font color=blue>return</font> icmp(s1, s2);
}

<font color=blue>auto</font> db = Database(<font color=red>":memory:"</font>);
db.<u>createCollation</u>!my_collation();
db.execute(<font color=red>"CREATE TABLE test (word TEXT)"</font>);

<font color=blue>auto</font> query = db.query(<font color=red>"INSERT INTO test (word) VALUES (:wd)"</font>);
<font color=blue>foreach</font> (word; [<font color=red>"straße"</font>, <font color=red>"strasses"</font>])
{
    query.bind(<font color=red>":wd"</font>, word);
    query.execute();
    query.reset();
}

query = db.query(<font color=red>"SELECT word FROM test ORDER BY word COLLATE my_collation"</font>);
<font color=blue>assert</font>(query.oneValue!string == <font color=red>"straße"</font>);
</pre>
<br><br>
</dd>
<dt><big><a name="Database.createFunction"></a>void <u>createFunction</u>(alias fun, string name = __traits(identifier, fun))();
</big></dt>
<dd>Creates and registers a simple function in the database.
<br><br>
The function <i>fun</i> must satisfy these criteria:
    <ul>        <li>It must not be a variadic.</li>
        <li>Its arguments must all have a type that is compatible with SQLite types:
             boolean, integral, floating point, string, or array of bytes (BLOB types).</li>
        <li>Its return value must also be of a compatible type.</li>
    </ul>
    The function will have the name <i>name</i> in the database; this name defaults to
    the identifier of the function fun.
<br><br>

    See also: <a href="http://www.sqlite.org/lang_corefunc.html">http://www.sqlite.org/lang_corefunc.html</a><br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> string my_msg(string name)
{
    <font color=blue>return</font> <font color=red>"Hello, %s!"</font>.format(name);
}

<font color=blue>auto</font> db = Database(<font color=red>":memory:"</font>);
db.<u>createFunction</u>!my_msg();

<font color=blue>auto</font> query = db.query(<font color=red>"SELECT my_msg('John')"</font>);
<font color=blue>assert</font>(query.oneValue!string() == <font color=red>"Hello, John!"</font>);
</pre>
<br><br>
</dd>
</dl>
</dd>
<dt><big><a name="Query"></a>struct <u>Query</u>;
</big></dt>
<dd>An interface to SQLite query execution.<br><br>

<dl><dt><big><a name="Query.statement"></a>@property sqlite3_stmt* <u>statement</u>();
</big></dt>
<dd>Gets the SQLite internal handle of the query statement.<br><br>

</dd>
<dt><big><a name="Query.bind"></a>void <u>bind</u>(T)(int <i>index</i>, T <i>value</i>);
<br><a name="Query.bind"></a>void <u>bind</u>(T)(string <i>name</i>, T <i>value</i>);
</big></dt>
<dd>Binds values to parameters in the query.
<br><br>
The index is the position of the parameter in the SQL query (starting from 0).
    The name must include the ':', '@' or '$' that introduces it in the query.<br><br>

</dd>
<dt><big><a name="Query.clearBindings"></a>void <u>clearBindings</u>();
</big></dt>
<dd>Clears the bindings.
<br><br>
This does not reset the prepared statement. Use Query.reset() for this.<br><br>

</dd>
<dt><big><a name="Query.reset"></a>void <u>reset</u>();
</big></dt>
<dd>Resets a query's prepared statement before a new execution.
<br><br>
This does not clear the bindings. Use Query.clear() for this.<br><br>

</dd>
<dt><big><a name="Query.execute"></a>void <u>execute</u>();
</big></dt>
<dd>Executes the query.
<br><br>
If the query is expected to return rows, use the query's input range interface
    to iterate over them.<br><br>

</dd>
<dt><big><a name="Query.empty"></a>@property bool <u>empty</u>();
<br><a name="Query.front"></a>@property Row <u>front</u>();
<br><a name="Query.popFront"></a>void <u>popFront</u>();
</big></dt>
<dd>InputRange interface. A <tt>Query</tt> is an input range of <tt>Row</tt>s.<br><br>

</dd>
<dt><big><a name="Query.oneValue"></a>auto <u>oneValue</u>(T)();
</big></dt>
<dd>Gets only the first value of the first row returned by a query.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> db = Database(<font color=red>":memory:"</font>);
db.execute(<font color=red>"CREATE TABLE test (val INTEGER)"</font>);
<font color=blue>auto</font> query = db.query(<font color=red>"SELECT count(*) FROM test"</font>);
<font color=blue>assert</font>(query.<u>oneValue</u>!<font color=blue>long</font> == 0);
</pre>
<br><br>
</dd>
</dl>
</dd>
<dt><big><a name="Row"></a>struct <u>Row</u>;
</big></dt>
<dd>A SQLite row, implemented as a random-access range of Variant.
<br><br>
<b>Warning:</b><br>
A <u>Row</u> is just a view of the current row when iterating the results of a <tt>Query</tt>.
    It becomes invalid as soon as <tt>Query.popFront</tt> is called. <u>Row</u> contains
    undefined data afterwards.<br><br>

<dl><dt><big><a name="Row.empty"></a>@property bool <u>empty</u>();
<br><a name="Row.front"></a>@property Variant <u>front</u>();
<br><a name="Row.popFront"></a>void <u>popFront</u>();
</big></dt>
<dd>Input range primitives.<br><br>

</dd>
<dt><big><a name="Row.save"></a>@property Row <u>save</u>();
</big></dt>
<dd>Forward range primitive.<br><br>

</dd>
<dt><big><a name="Row.back"></a>@property Variant <u>back</u>();
<br><a name="Row.popBack"></a>void <u>popBack</u>();
</big></dt>
<dd>Bidirectional range primitives.<br><br>

</dd>
<dt><big><a name="Row.length"></a>@property int <u>length</u>();
</big></dt>
<dd>Random access range primitives.<br><br>

</dd>
<dt><big><a name="Row.peek"></a>auto <u>peek</u>(T)(int <i>index</i>);
<br><a name="Row.peek"></a>auto <u>peek</u>(T)(string <i>name</i>);
</big></dt>
<dd>Return the content of a column, automatically cast to T.
<br><br>
T must be a boolean, a built-in numeric type, a string, an array or a Variant.

<br><br>
<b>Warning:</b><br>
If the column is specified by its name, the names of all the columns are tested
        each time this function is called: use numeric indexing for better performance.<br><br>

</dd>
<dt><big><a name="Row.opIndex"></a>Variant <u>opIndex</u>(int <i>index</i>);
<br><a name="Row.opIndex"></a>Variant <u>opIndex</u>(string <i>name</i>);
</big></dt>
<dd>Returns the data of a given column as a Variant.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="QueryCache"></a>struct <u>QueryCache</u>;
</big></dt>
<dd>Caches all the results of a Query in memory as Variants.
<br><br>
Allows to iterate on the rows and their columns with an array-like interface.
The rows can be viewed as an array of Variant or as an associative array of
Variant indexed by the column names.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> db = Database(<font color=red>":memory:"</font>);
db.execute(<font color=red>"CREATE TABLE test (msg TEXT, num FLOAT)"</font>);

<font color=blue>auto</font> query = db.query(<font color=red>"INSERT INTO test (msg, num) VALUES (:msg, :num)"</font>);
query.bind(<font color=red>":msg"</font>, <font color=red>"ABC"</font>);
query.bind(<font color=red>":num"</font>, 123);
query.execute();
query.reset();
query.bind(<font color=red>":msg"</font>, <font color=red>"DEF"</font>);
query.bind(<font color=red>":num"</font>, 456);
query.execute();

query = db.query(<font color=red>"SELECT * FROM test"</font>);
<font color=blue>auto</font> data = <u>QueryCache</u>(query);
<font color=blue>assert</font>(data.length == 2);
<font color=blue>assert</font>(data[0].front == <font color=red>"ABC"</font>);
<font color=blue>assert</font>(data[0][1] == 123);
<font color=blue>assert</font>(data[1][<font color=red>"msg"</font>] == <font color=red>"DEF"</font>);
<font color=blue>assert</font>(data[1][<font color=red>"num"</font>] == 456);
<font color=blue>assert</font>(data[1][<font color=red>"num"</font>].coerce!string == <font color=red>"456"</font>);
</pre>
<br><br>
<dl><dt><big><a name="QueryCache.this"></a>this(Query <i>query</i>);
</big></dt>
<dd>Creates and populates the cache from the results of the <i>query</i>.
<br><br>
<b>Warning:</b><br>
The <i>query</i> will be reset once this constructor have populated the cache.
        Don't call this constructor while using <i>query</i>'s range interface.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="literal"></a>string <u>literal</u>(T)(T <i>value</i>);
</big></dt>
<dd>Turns a value into a <u>literal</u> that can be used in an SQLite expression.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>assert</font>(<font color=blue>null</font>.<u>literal</u> == <font color=red>"NULL"</font>);
<font color=blue>assert</font>(<font color=blue>false</font>.<u>literal</u> == <font color=red>"0"</font>);
<font color=blue>assert</font>(<font color=blue>true</font>.<u>literal</u> == <font color=red>"1"</font>);
<font color=blue>assert</font>(4.<u>literal</u> == <font color=red>"4"</font>);
<font color=blue>assert</font>(4.1.<u>literal</u> == <font color=red>"4.1"</font>);
<font color=blue>assert</font>(<font color=red>"foo"</font>.<u>literal</u> == <font color=red>"'foo'"</font>);
<font color=blue>assert</font>(<font color=red>"a'b'"</font>.<u>literal</u> == <font color=red>"'a''b'''"</font>);
<font color=blue>auto</font> a = <font color=blue>cast</font>(<font color=blue>ubyte</font>[]) x"DEADBEEF";
<font color=blue>assert</font>(a.<u>literal</u> == <font color=red>"'XDEADBEEF'"</font>);
</pre>
<br><br>
</dd>
<dt><big><a name="SqliteException"></a>class <u>SqliteException</u>: <u>object.Exception</u>;
</big></dt>
<dd>Exception thrown when SQLite functions return an error.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. Copyright Nicolas Sicard, 2011-2014.

</small>
        </body></html>
