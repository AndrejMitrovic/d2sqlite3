<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>d2sqlite3</title>
        </head><body>
        <h1>d2sqlite3</h1>
        <!-- Generated by Ddoc from source/d2sqlite3.d -->
Simple SQLite interface.
<br><br>
This module provides a simple "object-oriented" interface to the SQLite
database engine. See example in the documentation for the Database struct
below. The (hopefully) complete C API is available through the <tt>sqlite3</tt>
module, which is publicly imported by this module.

<br><br>
<b>License:</b><br>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.

<br><br>
<b>Authors:</b><br>
Nicolas Sicard (dransic@gmail.com).

<br><br>

<dl><dt><big><a name="Sqlite3"></a>struct <u>Sqlite3</u>;
</big></dt>
<dd>Metadata from the SQLite library.<br><br>

<dl><dt><big><a name="Sqlite3.versionString"></a>static nothrow @property string <u>versionString</u>();
</big></dt>
<dd>Gets the library's version string (e.g. "3.8.7").<br><br>

</dd>
<dt><big><a name="Sqlite3.versionNumber"></a>static nothrow @property int <u>versionNumber</u>();
</big></dt>
<dd>Gets the library's version number (e.g. 3008007).<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Deterministic"></a>enum <u>Deterministic</u>: int;
</big></dt>
<dd>A caracteristic of user-defined functions or aggregates.<br><br>

<dl><dt><big><a name="Deterministic.yes"></a><u>yes</u></big></dt>
<dd>The returned value is the same if the function is called with the same
    parameters.<br><br>

</dd>
<dt><big><a name="Deterministic.no"></a><u>no</u></big></dt>
<dd>The returned value can vary even if the function is called with the same
    parameters.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Database"></a>struct <u>Database</u>;
</big></dt>
<dd>An interface to a SQLite database connection.
<br><br>
This struct is a reference-counted wrapper around a <tt>sqlite3*</tt> pointer.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=green>// Note: exception handling is left aside for clarity.
</font>
<font color=green>// Open a database in memory.
</font><font color=blue>auto</font> db = <u>Database</u>(<font color=red>":memory:"</font>);

<font color=green>// Create a table
</font>db.execute(
    <font color=red>"CREATE TABLE person (
        id INTEGER PRIMARY KEY,
        last_name TEXT NOT NULL,
        first_name TEXT,
        score FLOAT,
        photo BLOB
     )"</font>
);

<font color=green>// Populate the table.
</font><font color=blue>auto</font> query = db.query(
    <font color=red>"INSERT INTO person (last_name, first_name, score, photo)
     VALUES (:last_name, :first_name, :score, :photo)"</font>
);

<font color=green>// Bind values.
</font>query.bind(<font color=red>":last_name"</font>, <font color=red>"Smith"</font>);
query.bind(<font color=red>":first_name"</font>, <font color=red>"John"</font>);
query.bind(<font color=red>":score"</font>, 77.5);
query.bind(<font color=red>":photo"</font>, [0xDE, 0xEA, 0xBE, 0xEF]);
query.execute();

query.reset(); <font color=green>// Need to reset the query after execution.
</font>query.bind(<font color=red>":last_name"</font>, <font color=red>"Doe"</font>);
query.bind(<font color=red>":first_name"</font>, <font color=red>"John"</font>);
query.bind(3, 46.8); <font color=green>// Use of index instead of name.
</font>query.bind(<font color=red>":photo"</font>, <font color=blue>null</font>);
query.execute();

<font color=green>// Count the changes
</font><font color=blue>assert</font>(db.totalChanges == 2);

<font color=green>// Count the Johns in the table.
</font>query = db.query(<font color=red>"SELECT count(*) FROM person WHERE first_name == 'John'"</font>);
<font color=blue>assert</font>(query.oneValue!<font color=blue>long</font> == 2);

<font color=green>// Read the data from the table lazily
</font>query = db.query(<font color=red>"SELECT * FROM person"</font>);
<font color=blue>foreach</font> (row; query)
{
    <font color=green>// Retrieve "id", which is the column at index 0, and contains an int,
</font>    <font color=green>// e.g. using the peek function (best performance).
</font>    <font color=blue>auto</font> id = row.peek!<font color=blue>long</font>(0);

    <font color=green>// Retrieve "last_name" and "first_name", e.g. using opIndex(string),
</font>    <font color=green>// which returns a ColumnData.
</font>    <font color=blue>auto</font> name = format(<font color=red>"%s, %s"</font>, row[<font color=red>"last_name"</font>].as!string, row[<font color=red>"first_name"</font>].as!string);

    <font color=green>// Retrieve "score", which is at index 3, e.g. using the peek function.
</font>    <font color=blue>auto</font> score = row.peek!<font color=blue>double</font>(<font color=red>"score"</font>);
    
    <font color=green>// Retrieve "photo", e.g. using opIndex(index),
</font>    <font color=green>// which returns a ColumnData.
</font>    <font color=blue>auto</font> photo = row[4].as!(<font color=blue>ubyte</font>[]);
    
    <font color=green>// ... and use all these data!
</font>}

<font color=green>// Read all the table in memory at once
</font><font color=blue>auto</font> data = QueryCache(db.query(<font color=red>"SELECT * FROM person"</font>));
<font color=blue>foreach</font> (row; data)
{
    <font color=blue>auto</font> id = row[0].as!<font color=blue>long</font>;
    <font color=blue>auto</font> name = format(<font color=red>"%s, %s"</font>, row[<font color=red>"last_name"</font>], row[<font color=red>"first_name"</font>]);
    <font color=blue>auto</font> score = row[<font color=red>"score"</font>].as!<font color=blue>double</font>;
    <font color=blue>auto</font> photo = row[4].as!(<font color=blue>ubyte</font>[]);
    <font color=green>// etc.
</font>}
</pre>
<br><br>
<dl><dt><big><a name="Database.this"></a>this(string <i>path</i>, int <i>flags</i> = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE);
</big></dt>
<dd>Opens a database connection.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>path</i></td>
<td>The <i>path</i> to the database file. In recent versions of SQLite, the
    <i>path</i> can be an URI with options.</td></tr>
<tr><td>int <i>flags</i></td>
<td>Options <i>flags</i>.</td></tr>
</table><br>
<b>See Also:</b><br>
<a href="http://www.sqlite.org/c3ref/open.html">http://www.sqlite.org/c3ref/open.html</a> to know how to use
    the <i>flags</i> parameter or to use <i>path</i> as a file URI if the current
    configuration allows it.<br><br>

</dd>
<dt><big><a name="Database.handle"></a>pure nothrow @property @safe sqlite3* <u>handle</u>();
</big></dt>
<dd>Gets the SQLite internal handle of the database connection.<br><br>

</dd>
<dt><big><a name="Database.close"></a>void <u>close</u>();
</big></dt>
<dd>Explicitly closes the database.
<br><br>
After this function has been called successfully, the result of using this
    database object or a query depending on is undefined.<br><br>

</dd>
<dt><big><a name="Database.execute"></a>void <u>execute</u>(F = typeof(null))(string <i>sql</i>, F <i>callback</i> = null);
</big></dt>
<dd>Executes the given SQL code.
<br><br>
<b>Params:</b><br>
<table><tr><td>string sql</td>
<td>The SQL statements that should be executed.</td></tr>
<tr><td>F callback</td>
<td>A function that will be called on each row returned by the
        excecution. The first argument of the callback is a <tt>string[]</tt> that
        will contain the names of the row's columns. The second argument of the
        callback is a <tt>string[]</tt> that will contain the data of the row's
        columns. The callback must return an <tt>int</tt> or <tt>void</tt>. If the
        callback returns an <tt>int</tt> that is not zero, the execution of the
        query is aborted.</td></tr>
</table><br>
<b>See Also:</b><br>
<a href="http://www.sqlite.org/c3ref/exec.html">http://www.sqlite.org/c3ref/exec.html</a>.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> db = Database(<font color=red>":memory:"</font>);
db.<u>execute</u>(<font color=red>"VACUUM"</font>);
</pre>
<br><br><b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> <font color=blue>int</font> printRows(string[] names, string[] texts)
{
    <font color=green>// use names and texts
</font>    <font color=green>// [...]
</font>
    <font color=blue>return</font> 0;
}

<font color=blue>auto</font> db = Database(<font color=red>":memory:"</font>);
db.<u>execute</u>(<font color=red>"EXPLAIN VACUUM"</font>, &amp;printRows);
</pre>
<br><br>
</dd>
<dt><big><a name="Database.query"></a>Query <u>query</u>(string <i>sql</i>);
</big></dt>
<dd>Creates a query on the database and returns it.
<br><br>
The query becomes invalid if the Database goes out of scope and is
    destroyed.<br><br>

</dd>
<dt><big><a name="Database.changes"></a>nothrow @property int <u>changes</u>();
</big></dt>
<dd>Gets the number of database rows that were changed, inserted or deleted by
    the most recently completed query.<br><br>

</dd>
<dt><big><a name="Database.totalChanges"></a>nothrow @property int <u>totalChanges</u>();
</big></dt>
<dd>Gets the number of database rows that were changed, inserted or deleted
    since the database was opened.<br><br>

</dd>
<dt><big><a name="Database.errorCode"></a>nothrow @property int <u>errorCode</u>();
</big></dt>
<dd>Gets the SQLite error code of the last operation.<br><br>

</dd>
<dt><big><a name="Database.errorMsg"></a>nothrow @property string <u>errorMsg</u>();
</big></dt>
<dd>Gets the SQLite error message of the last operation.<br><br>

</dd>
<dt><big><a name="Database.createFunction"></a>void <u>createFunction</u>(alias fun, string name = __traits(identifier, fun), Deterministic det = Deterministic.yes)(void* <i>userData</i> = null);
</big></dt>
<dd>Creates and registers a simple function in the database.
<br><br>
<b>Params:</b><br>
<table><tr><td>fun</td>
<td>An alias to the D implementation of the function.
            The function <i>fun</i> must satisfy these criteria:
            <ul>                <li>It must not be a variadic.</li>
                <li>Its arguments must all have a type that is compatible with
                SQLite types: boolean, integral, floating point, string, or
                array of bytes (BLOB types).</li>
                <li>It can have only one parameter of type <tt>void*</tt> and it
                must be the last one.</li>
                <li>Its return value must also be of a compatible type.</li>
            </ul></td></tr>
<tr><td>name</td>
<td>The name that the function will have in the database; this name
        defaults to the identifier of <i>fun</i>.</td></tr>
<tr><td>det</td>
<td>Tells SQLite whether the result of the function is deterministic,
        i.e. if the result is the same when called with the same parameters.
        Recent versions of SQLite perform optimizations based on this. Set to
        <tt>Deterministic.no</tt> otherwise.</td></tr>
<tr><td>void* userData</td>
<td>A pointer to some user data, that will be passed to
        <i>fun</i> as its last argument if its type is <tt>void*</tt>.</td></tr>
</table><br>
<b>See Also:</b><br>
<a href="http://www.sqlite.org/c3ref/create_function.html">http://www.sqlite.org/c3ref/create_function.html</a>.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> string my_msg(string name)
{
    <font color=blue>return</font> <font color=red>"Hello, %s!"</font>.format(name);
}

<font color=blue>auto</font> db = Database(<font color=red>":memory:"</font>);
db.<u>createFunction</u>!my_msg();

<font color=blue>auto</font> query = db.query(<font color=red>"SELECT my_msg('John')"</font>);
<font color=blue>assert</font>(query.oneValue!string() == <font color=red>"Hello, John!"</font>);
</pre>
<br><br><b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> string fun(string msg, <font color=blue>void</font>* data)
{
    <font color=blue>auto</font> ptr = <font color=blue>cast</font>(<font color=blue>int</font>*) data;
    <font color=blue>return</font> <font color=red>"%s %d"</font>.format(msg, *ptr);
}

<font color=blue>int</font> value = 42;
<font color=blue>auto</font> db = Database(<font color=red>":memory:"</font>);
db.<u>createFunction</u>!fun(&amp;value);
<font color=blue>auto</font> query = db.query(<font color=red>"SELECT fun('The number is')"</font>);
<font color=blue>assert</font>(query.oneValue!string() == <font color=red>"The number is 42"</font>);
</pre>
<br><br>
</dd>
<dt><big><a name="Database.createAggregate"></a>void <u>createAggregate</u>(Aggregate, string name = __traits(identifier, Aggregate), Deterministic det = Deterministic.yes)();
</big></dt>
<dd>Creates and registers a new aggregate function in the database.
<br><br>
<b>Params:</b><br>
<table><tr><td>Aggregate</td>
<td>The <tt>struct</tt> implementing the aggregate. Aggregate must
        be a default-constructible <strong><tt>struct</tt></strong> that implements at least these
        two methods: <tt>accumulate</tt> and <tt>result</tt>.</td></tr>
<tr><td>name</td>
<td>The name that the function will have in the database; this name
        defaults to the identifier of <i>Aggregate</i>.</td></tr>
<tr><td>det</td>
<td>Tells SQLite whether the result of the function is deterministic,
        i.e. if the result is the same when called with the same parameters.
        Recent versions of SQLite perform optimizations based on this. Set to
        <tt>Deterministic.no</tt> otherwise.</td></tr>
</table><br>
<b>See Also:</b><br>
<a href="http://www.sqlite.org/c3ref/create_function.html">http://www.sqlite.org/c3ref/create_function.html</a>.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>struct</font> weighted_average
{
    <font color=blue>double</font> total_value = 0.0;
    <font color=blue>double</font> total_weight = 0.0;
    
    <font color=blue>void</font> accumulate(<font color=blue>double</font> value, <font color=blue>double</font> weight)
    {
        total_value += value * weight;
        total_weight += weight;
    }
    
    <font color=blue>double</font> result()
    {
        <font color=blue>return</font> total_value / total_weight;
    }
}

<font color=blue>auto</font> db = Database(<font color=red>":memory:"</font>);
db.execute(<font color=red>"CREATE TABLE test (value FLOAT, weight FLOAT)"</font>);
db.<u>createAggregate</u>!(weighted_average, <font color=red>"w_avg"</font>)();

<font color=blue>auto</font> query = db.query(<font color=red>"INSERT INTO test (value, weight) VALUES (?1, ?2)"</font>);
<font color=blue>double</font>[<font color=blue>double</font>] list = [11.5: 3, 14.8: 1.6, 19: 2.4];
<font color=blue>foreach</font> (value, weight; list)
{
    query.bind(1, value);
    query.bind(2, weight);
    query.execute();
    query.reset();
}

query = db.query(<font color=red>"SELECT w_avg(value, weight) FROM test"</font>);
<font color=blue>import</font> std.math: approxEqual;        
<font color=blue>assert</font>(approxEqual(query.oneValue!<font color=blue>double</font>, (11.5*3 + 14.8*1.6 + 19*2.4)/(3 + 1.6 + 2.4)));
</pre>
<br><br>
</dd>
<dt><big><a name="Database.createCollation"></a>void <u>createCollation</u>(alias fun, string name = __traits(identifier, fun))();
</big></dt>
<dd>Creates and registers a collation function in the database.
<br><br>
<b>Params:</b><br>
<table><tr><td>fun</td>
<td>An alias to the D implementation of the function.
            The function <i>fun</i> must satisfy these criteria:
            <ul>                <li>If s1 is less than s2, <tt>ret &lt; 0</tt>.</li>
                <li>If s1 is equal to s2, <tt>ret == 0</tt>.</li>
                <li>If s1 is greater than s2, <tt>ret &gt; 0</tt>.</li>
                <li>If s1 is equal to s2, then s2 is equal to s1.</li>
                <li>If s1 is equal to s2 and s2 is equal to s3, then s1 is
                equal to s3.</li>
                <li>If s1 is less than s2, then s2 is greater than s1.</li>
                <li>If s1 is less than s2 and s2 is less than s3, then s1 is
                less than s3.</li>
            </ul></td></tr>
<tr><td>name</td>
<td>The name that the function will have in the database; this name
        defaults to the identifier of <i>fun</i>.</td></tr>
</table><br>
<b>See Also:</b><br>
<a href="http://www.sqlite.org/lang_aggfunc.html">http://www.sqlite.org/lang_aggfunc.html</a><br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> <font color=blue>int</font> my_collation(string s1, string s2)
{
    <font color=blue>import</font> std.uni;
    <font color=blue>return</font> icmp(s1, s2);
}

<font color=blue>auto</font> db = Database(<font color=red>":memory:"</font>);
db.<u>createCollation</u>!my_collation();
db.execute(<font color=red>"CREATE TABLE test (word TEXT)"</font>);

<font color=blue>auto</font> query = db.query(<font color=red>"INSERT INTO test (word) VALUES (?)"</font>);
<font color=blue>foreach</font> (word; [<font color=red>"straße"</font>, <font color=red>"strasses"</font>])
{
    query.bind(1, word);
    query.execute();
    query.reset();
}

query = db.query(<font color=red>"SELECT word FROM test ORDER BY word COLLATE my_collation"</font>);
<font color=blue>assert</font>(query.oneValue!string == <font color=red>"straße"</font>);
</pre>
<br><br>
</dd>
</dl>
</dd>
<dt><big><a name="Query"></a>struct <u>Query</u>;
</big></dt>
<dd>An interface to SQLite query execution.
<br><br>
This struct is a wrapper around a <tt>sqlite3_stmt*</tt> pointer. Instances of this
struct are typically returned by <tt>Database.query()</tt>.<br><br>

<dl><dt><big><a name="Query.statement"></a>@property sqlite3_stmt* <u>statement</u>();
</big></dt>
<dd>Gets the SQLite internal handle of the statement.<br><br>

</dd>
<dt><big><a name="Query.bind"></a>void <u>bind</u>(T)(int <i>index</i>, T <i>value</i>);
</big></dt>
<dd>Binds values to parameters in a prepared statement.
<br><br>
<b>Params:</b><br>
<table><tr><td>int index</td>
<td>The index of the parameter (starting from 1).</td></tr>
<tr><td>T value</td>
<td>The bound value. The type of value must be compatible with the
        SQLite types: it must be a boolean or numeric type, a string or an
        array.</td></tr>
</table><br>

</dd>
<dt><big><a name="Query.bind"></a>void <u>bind</u>(T)(string <i>name</i>, T <i>value</i>);
</big></dt>
<dd>Binds values to parameters in a prepared statement.
<br><br>
<b>Params:</b><br>
<table><tr><td>string name</td>
<td>The name of the parameter (starting from 0), include the ':',
        '@' or '$' that introduces it.</td></tr>
<tr><td>T value</td>
<td>The bound value. The type of value must be compatible with the
        SQLite types: it must be a boolean or numeric type, a string or an
        array.</td></tr>
</table><br>
<b>Warning:</b><br>
While convenient, this overload of <tt><u>bind</u></tt> is less performant,
        because it has to retrieve the column index with a call to the SQLite
        function <tt>sqlite3_bind_parameter_index</tt>.<br><br>

</dd>
<dt><big><a name="Query.clearBindings"></a>void <u>clearBindings</u>();
</big></dt>
<dd>Clears the bindings.
<br><br>
This does not reset the prepared statement. Use <tt>Query.reset()</tt> for this.<br><br>

</dd>
<dt><big><a name="Query.reset"></a>void <u>reset</u>();
</big></dt>
<dd>Resets a query's prepared statement before a new execution.
<br><br>
This does not clear the bindings. Use <tt>Query.clear()</tt> for this.<br><br>

</dd>
<dt><big><a name="Query.execute"></a>void <u>execute</u>();
</big></dt>
<dd>Executes the query.
<br><br>
If the query is expected to return rows, use the query's input range
    interface to iterate over them.<br><br>

</dd>
<dt><big><a name="Query.empty"></a>@property bool <u>empty</u>();
<br><a name="Query.front"></a>@property Row <u>front</u>();
<br><a name="Query.popFront"></a>void <u>popFront</u>();
</big></dt>
<dd>Input range interface. A <tt>Query</tt> is an input range of <tt>Row</tt>s.
<br><br>
<b>Warning:</b><br>
A Row becomes invalid as soon as <tt>Query.popFront</tt> is called (it
    contains undefined data afterwards).<br><br>

</dd>
<dt><big><a name="Query.oneValue"></a>auto <u>oneValue</u>(T)();
</big></dt>
<dd>Gets only the first value of the first row returned by a query.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> db = Database(<font color=red>":memory:"</font>);
db.execute(<font color=red>"CREATE TABLE test (val INTEGER)"</font>);
<font color=blue>auto</font> query = db.query(<font color=red>"SELECT count(*) FROM test"</font>);
<font color=blue>assert</font>(query.<u>oneValue</u>!<font color=blue>long</font> == 0);
</pre>
<br><br>
</dd>
</dl>
</dd>
<dt><big><a name="Row"></a>struct <u>Row</u>;
</big></dt>
<dd>A SQLite row, implemented as a random-access range of ColumnData.
<br><br>
<b>Warning:</b><br>
A <u>Row</u> is just a view of the current row when iterating the results of
a <tt>Query</tt>. It becomes invalid as soon as <tt>Query.popFront()</tt> is called. <u>Row</u>
contains undefined data afterwards.<br><br>

<dl><dt><big><a name="Row.empty"></a>pure nothrow @property @safe bool <u>empty</u>();
<br><a name="Row.front"></a>nothrow @property ColumnData <u>front</u>();
<br><a name="Row.popFront"></a>pure nothrow @safe void <u>popFront</u>();
<br><a name="Row.save"></a>pure nothrow @property @safe Row <u>save</u>();
<br><a name="Row.back"></a>nothrow @property ColumnData <u>back</u>();
<br><a name="Row.popBack"></a>pure nothrow @safe void <u>popBack</u>();
<br><a name="Row.length"></a>pure nothrow @property @safe int <u>length</u>();
<br><a name="Row.opIndex"></a>ColumnData <u>opIndex</u>(int <i>index</i>);
</big></dt>
<dd>Range interface.<br><br>

</dd>
<dt><big><a name="Row.opIndex"></a>ColumnData <u>opIndex</u>(string <i>name</i>);
</big></dt>
<dd>Returns the data of a column as a <tt>ColumnData</tt>.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>name</i></td>
<td>The <i>name</i> of the column, as specified in the prepared statement
        with an AS clause.</td></tr>
</table><br>

</dd>
<dt><big><a name="Row.peek"></a>auto <u>peek</u>(T)(int <i>index</i>);
</big></dt>
<dd>Returns the data of a column.
<br><br>
Contraty to <tt>opIndex</tt>, the <tt><u>peek</u></tt> functions return the data directly,
    automatically cast to T, without the overhead of using a wrapped <tt>    Variant</tt> (<tt>ColumnData</tt>).

<br><br>
<b>Params:</b><br>
<table><tr><td>T</td>
<td>The type of the returned data. T must be a boolean, a built-in
        numeric type, a string, an array or a Variant.</td></tr>
<tr><td>int index</td>
<td>The index of the column in the prepared statement.</td></tr>
</table><br>
<b>Returns:</b><br>
A value of type T, or T.init if the data is NULL.

<br><br>
<b>Warning:</b><br>
The result is undefined if then index is out of range.<br><br>

</dd>
<dt><big><a name="Row.peek"></a>auto <u>peek</u>(T)(string <i>name</i>);
</big></dt>
<dd>Returns the data of a column.
<br><br>
Contraty to <tt>opIndex</tt>, the <tt><u>peek</u></tt> functions return the data directly,
    automatically cast to T, without the overhead of using a wrapped <tt>    Variant</tt> (<tt>ColumnData</tt>).

<br><br>
<b>Params:</b><br>
<table><tr><td>T</td>
<td>The type of the returned data. T must be a boolean, a built-in
        numeric type, a string, an array or a Variant.</td></tr>
<tr><td>string name</td>
<td>The name of the column, as specified in the prepared statement
        with an AS clause.</td></tr>
</table><br>
<b>Returns:</b><br>
A value of type T, or T.init if the data is NULL.

<br><br>
<b>Warning:</b><br>
The names of all the columns are tested each time this function is
<br><br>
<b>called:</b><br>
use numeric indexing for better performance.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="ColumnData"></a>struct <u>ColumnData</u>;
</big></dt>
<dd>The data retrived from a column, stored internally as a <tt>Variant</tt>, which is
accessible through "<tt>alias this</tt>".<br><br>

<dl><dt><big><a name="ColumnData.as"></a>auto <u>as</u>(T)(T <i>defaultValue</i> = T.init);
</big></dt>
<dd>Returns the data converted to T. If the data is NULL, defaultValue is
    returned.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="QueryCache"></a>struct <u>QueryCache</u>;
</big></dt>
<dd>Caches all the results of a <tt>Query</tt> in memory as <tt>ColumnData</tt>.
<br><br>
Allows to iterate on the rows and their columns with an array-like interface.
The rows can be viewed as an array of <tt>ColumnData</tt> or as an associative
array of <tt>ColumnData</tt> indexed by the column names.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> db = Database(<font color=red>":memory:"</font>);
db.execute(<font color=red>"CREATE TABLE test (msg TEXT, num FLOAT)"</font>);

<font color=blue>auto</font> query = db.query(<font color=red>"INSERT INTO test (msg, num) VALUES (?1, ?2)"</font>);
query.bind(1, <font color=red>"ABC"</font>);
query.bind(2, 123);
query.execute();
query.reset();
query.bind(1, <font color=red>"DEF"</font>);
query.bind(2, 456);
query.execute();

query = db.query(<font color=red>"SELECT * FROM test"</font>);
<font color=blue>auto</font> data = <u>QueryCache</u>(query);
<font color=blue>assert</font>(data.length == 2);
<font color=blue>assert</font>(data[0].front.as!string == <font color=red>"ABC"</font>);
<font color=blue>assert</font>(data[0][1].as!<font color=blue>int</font> == 123);
<font color=blue>assert</font>(data[1][<font color=red>"msg"</font>].as!string == <font color=red>"DEF"</font>);
<font color=blue>assert</font>(data[1][<font color=red>"num"</font>].as!<font color=blue>int</font> == 456);
</pre>
<br><br>
<dl><dt><big><a name="QueryCache.this"></a>this(Query <i>query</i>);
</big></dt>
<dd>Creates and populates the cache from the results of the <i>query</i>.
<br><br>
<b>Warning:</b><br>
The <i>query</i> will be reset once this constructor have populated the cache.
        Don't call this constructor while iterating the <i>query</i>'s range interface.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="literal"></a>string <u>literal</u>(T)(T <i>value</i>);
</big></dt>
<dd>Turns <i>value</i> into a literal that can be used in an SQLite expression.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>assert</font>(<font color=blue>null</font>.<u>literal</u> == <font color=red>"NULL"</font>);
<font color=blue>assert</font>(<font color=blue>false</font>.<u>literal</u> == <font color=red>"0"</font>);
<font color=blue>assert</font>(<font color=blue>true</font>.<u>literal</u> == <font color=red>"1"</font>);
<font color=blue>assert</font>(4.<u>literal</u> == <font color=red>"4"</font>);
<font color=blue>assert</font>(4.1.<u>literal</u> == <font color=red>"4.1"</font>);
<font color=blue>assert</font>(<font color=red>"foo"</font>.<u>literal</u> == <font color=red>"'foo'"</font>);
<font color=blue>assert</font>(<font color=red>"a'b'"</font>.<u>literal</u> == <font color=red>"'a''b'''"</font>);
<font color=blue>auto</font> a = <font color=blue>cast</font>(<font color=blue>ubyte</font>[]) x"DEADBEEF";
<font color=blue>assert</font>(a.<u>literal</u> == <font color=red>"'XDEADBEEF'"</font>);
</pre>
<br><br>
</dd>
<dt><big><a name="SqliteException"></a>class <u>SqliteException</u>: <u>object.Exception</u>;
</big></dt>
<dd>Exception thrown when SQLite functions return an error.<br><br>

<dl><dt><big><a name="SqliteException.code"></a>int <u>code</u>;
</big></dt>
<dd>The code of the error that raised the exception, or 0 if this code is not known.<br><br>

</dd>
<dt><big><a name="SqliteException.sql"></a>string <u>sql</u>;
</big></dt>
<dd>The SQL code that raised the exception, if applicable.<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. Copyright Nicolas Sicard, 2011-2014.

</small>
        </body></html>
